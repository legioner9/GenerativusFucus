'use strict';

const { propObj, generativusFucus } = require('v.2');

propObj.returnBfn = (bfn, closureForFn) => {
  if (!closureForFn.flags.kill) {
    return bfn;
  } else return () => undefined;
};

propObj.comutClosure = (closureForFn) => {
  // debugger
  if (closureForFn.context.counter >= closureForFn.context.max) closureForFn.flags.kill = true;
  else closureForFn.context.counter++;
  return closureForFn;
};

propObj.methods = {
  printFn() {
    console.log(propObj.closureForFn.bfn);
    return this;
  },
  limit(max = 0) {
    propObj.closureForFn.context.max = max;
    return this;
  },
  timer(msec = 0) {
    const timer_ = setTimeout(() => {
      propObj.closureForFn.flags.kill = true;
      timer_.close();
    }, msec);
    return this;
  },
  cancel() {
    propObj.closureForFn.flags.kill = true;
  },
  resume() {
    propObj.closureForFn.flags.kill = false;
  },
  throttle(msec) {
    const interval = setInterval(() => {
      // debugger
      propObj.closureForFn.context.counter = 0;
    }, msec);
    return this;
  }
};


// propObj.closureForFn.context.max = 2;

const fn = function(...args) {
  console.dir({ args, this: this });
};

// Use
// debugger
const fucus = generativusFucus(propObj, fn).limit(3)
fucus.throttle(500);
fucus(0);
let count = 0;
const interval1 = setInterval(() => {
  // debugger
  fucus(count++);
}, 100);

// const timer1 = setTimeout(() => {
//   timer1.close();
//   interval1.close();
//   propObj.closureForFn.timer.interval.close();
// }, 1500);

